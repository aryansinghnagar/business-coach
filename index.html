<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Meeting Copilot</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script>
        // WebRTC polyfill for RTCPeerConnection.getConfiguration (required for avatar audio)
        (function() {
            if (typeof RTCPeerConnection === 'undefined') return;
            
            const OriginalRTC = window.RTCPeerConnection;
            const getConfigImpl = function() {
                return { iceServers: [], iceTransportPolicy: 'all', bundlePolicy: 'balanced' };
            };
            
            if (typeof OriginalRTC.prototype.getConfiguration !== 'function') {
                OriginalRTC.prototype.getConfiguration = getConfigImpl;
            }
            
            window.RTCPeerConnection = new Proxy(OriginalRTC, {
                construct: function(target, args) {
                    const pc = new target(...args);
                    if (typeof pc.getConfiguration !== 'function') {
                        pc.getConfiguration = getConfigImpl;
                    }
                    return pc;
                },
                get: function(target, prop) {
                    return target[prop];
                }
            });
        })();
    </script>
    <script src="https://aka.ms/csspeech/jsbrowserpackageraw"></script>
    <script>
        // Re-apply WebRTC polyfill after SDK loads
        (function() {
            if (typeof RTCPeerConnection === 'undefined') return;
            
            const getConfigImpl = function() {
                return { iceServers: [], iceTransportPolicy: 'all', bundlePolicy: 'balanced' };
            };
            
            if (typeof RTCPeerConnection.prototype.getConfiguration !== 'function') {
                RTCPeerConnection.prototype.getConfiguration = getConfigImpl;
            }
        })();
    </script>
    
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            background-attachment: fixed;
            color: #fff;
            min-height: 100vh;
            padding: 24px;
            position: relative;
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 119, 198, 0.3) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }
        
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 12px;
            text-align: center;
            background: linear-gradient(135deg, #ffffff 0%, #e0e7ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        
        .status-indicator {
            padding: 16px 24px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            margin-bottom: 24px;
            text-align: center;
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            font-weight: 500;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 32px;
            justify-content: center;
        }
        
        button {
            padding: 14px 28px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 14px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover:not(:disabled)::before {
            left: 100%;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        button.secondary {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.1);
        }
        
        button.secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }
        
        button.danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 0 4px 14px rgba(239, 68, 68, 0.4);
        }
        
        button.danger:hover:not(:disabled) {
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
        }
        
        .chat-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 32px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.2),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 32px;
            align-items: start;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .video-section {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }
        
        .video-container {
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }
        
        .engagement-bar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            min-width: 60px;
            padding: 16px 8px;
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .engagement-bar-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            margin-bottom: 8px;
        }
        
        .engagement-bar-wrapper {
            position: relative;
            width: 24px;
            height: 400px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .engagement-bar-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 0%;
            /* Color will be set dynamically via JavaScript based on score */
            background: linear-gradient(180deg, rgba(239, 68, 68, 0.7) 0%, rgba(239, 68, 68, 0.9) 100%);
            transition: height 0.5s cubic-bezier(0.4, 0, 0.2, 1), background 0.3s ease;
            border-radius: 10px;
            box-shadow: 
                0 -4px 12px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.2);
        }
        
        .engagement-bar-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-90deg);
            font-size: 1rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
            z-index: 10;
        }
        
        .engagement-level-indicator {
            font-size: 0.7rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            margin-top: 8px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            min-height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* 30 Signifier Metrics Panel (beneath avatar chat) */
        .engagement-signifiers-panel {
            margin-top: 24px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 20px 24px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }
        .signifier-panel-inner { max-width: 100%; }
        .signifier-panel-header {
            font-size: 1rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.95);
            margin-bottom: 16px;
            letter-spacing: 0.02em;
        }
        .signifier-panel-groups {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        .signifier-group {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 12px;
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        .signifier-group-title {
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgba(255, 255, 255, 0.85);
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
        }
        .signifier-list { display: flex; flex-direction: column; gap: 6px; }
        .signifier-row {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.8rem;
        }
        .signifier-label {
            flex: 0 0 140px;
            color: rgba(255, 255, 255, 0.9);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .signifier-bar {
            flex: 1;
            min-width: 60px;
            height: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            overflow: hidden;
        }
        .signifier-bar-fill {
            height: 100%;
            width: 0%;
            border-radius: 3px;
            transition: width 0.25s ease, background 0.2s ease;
        }
        .signifier-value {
            flex: 0 0 28px;
            text-align: right;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.95);
            font-variant-numeric: tabular-nums;
        }
        
        /* Video Source Selector Modal Styles */
        .video-source-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .video-source-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .video-source-modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
        }
        
        .video-source-modal-content {
            position: relative;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        
        .video-source-modal.active .video-source-modal-content {
            transform: scale(1);
        }
        
        .video-source-modal-header {
            margin-bottom: 24px;
            text-align: center;
        }
        
        .video-source-modal-header h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .video-source-modal-header p {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .video-source-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 24px;
        }
        
        .video-source-option {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .video-source-option:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .video-source-option input[type="radio"]:checked + label ~ *,
        .video-source-option:has(input[type="radio"]:checked) {
            background: rgba(99, 102, 241, 0.2);
            border-color: rgba(99, 102, 241, 0.5);
        }
        
        .video-source-icon {
            font-size: 2rem;
            flex-shrink: 0;
        }
        
        .video-source-info {
            flex: 1;
        }
        
        .video-source-info h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 4px;
            color: #fff;
        }
        
        .video-source-info p {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .video-source-radio {
            flex-shrink: 0;
        }
        
        .video-source-radio input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #6366f1;
        }
        
        .video-source-file-input {
            margin-bottom: 24px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
        }
        
        .file-input-label {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
        }
        
        .file-input-button {
            padding: 10px 20px;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.5);
            border-radius: 8px;
            color: #fff;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .file-input-button:hover {
            background: rgba(99, 102, 241, 0.3);
            border-color: rgba(99, 102, 241, 0.7);
        }
        
        .file-input-text {
            color: #9ca3af;
            font-size: 0.9rem;
        }
        
        .file-input-hint {
            margin-top: 8px;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .face-detection-method-selector {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .face-detection-method-selector label {
            display: block;
            margin-bottom: 12px;
            font-weight: 600;
            color: #fff;
        }
        
        .face-detection-method-option {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s ease;
            margin-bottom: 12px;
        }
        
        .face-detection-method-option:hover:not(:has(input:disabled)) {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(99, 102, 241, 0.5);
        }
        
        .face-detection-method-option:has(input:checked) {
            background: rgba(99, 102, 241, 0.15);
            border-color: rgba(99, 102, 241, 0.7);
        }
        
        .face-detection-method-option:has(input:disabled) {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .face-detection-method-option input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #6366f1;
            flex-shrink: 0;
        }
        
        .face-detection-method-option input[type="radio"]:disabled {
            cursor: not-allowed;
        }
        
        .face-detection-method-info {
            flex: 1;
        }
        
        .face-detection-method-title {
            font-weight: 500;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .face-detection-method-description {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .video-source-modal-footer {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        
        .btn-cancel,
        .btn-confirm {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            font-size: 0.9rem;
        }
        
        .btn-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
        }
        
        .btn-cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .btn-confirm {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: #fff;
        }
        
        .btn-confirm:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }
        
        #remoteVideo {
            flex: 1;
            width: 100%;
            aspect-ratio: 16/9;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 20px;
            overflow: hidden;
            position: relative;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 0 0 1px rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        #remoteVideo:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.4),
                inset 0 0 0 1px rgba(255, 255, 255, 0.15);
        }
        
        #remoteVideo video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        
        #subtitles {
            width: 90%;
            text-align: center;
            color: white;
            text-shadow: 
                -1px -1px 2px rgba(0, 0, 0, 0.8),
                1px -1px 2px rgba(0, 0, 0, 0.8),
                -1px 1px 2px rgba(0, 0, 0, 0.8),
                1px 1px 2px rgba(0, 0, 0, 0.8);
            position: absolute;
            bottom: 8%;
            left: 5%;
            z-index: 999;
            font-size: 1.15rem;
            font-weight: 600;
            padding: 14px 24px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease;
        }
        
        .chat-transcription-section {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        
        .chat-transcription-header {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.95);
            font-weight: 600;
            font-size: 1rem;
            letter-spacing: 0.01em;
        }
        
        #chatHistory {
            border: none;
            border-radius: 0;
            resize: none;
            background-color: rgba(15, 23, 42, 0.4);
            backdrop-filter: blur(10px);
            overflow-y: auto;
            overflow-x: hidden;
            color: rgba(255, 255, 255, 0.95);
            padding: 24px;
            font-size: 0.95rem;
            line-height: 1.7;
            width: 100%;
            min-height: 400px;
            max-height: calc(100vh - 400px);
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease;
        }
        
        #chatHistory:focus {
            background-color: rgba(15, 23, 42, 0.5);
            outline: none;
        }
        
        #chatHistory::-webkit-scrollbar {
            width: 10px;
        }
        
        #chatHistory::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        #chatHistory::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.05);
        }
        
        #chatHistory::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        #chatHistory:empty::before {
            content: "Chat conversation will appear here...";
            color: rgba(255, 255, 255, 0.4);
            font-style: italic;
            font-weight: 400;
        }
        
        .message-input-container {
            margin-top: 24px;
        }
        
        .message-input-wrapper {
            display: flex;
            gap: 12px;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        
        .message-input-wrapper:focus-within {
            border-color: rgba(102, 126, 234, 0.6);
            box-shadow: 
                0 0 0 4px rgba(102, 126, 234, 0.15),
                0 6px 24px rgba(0, 0, 0, 0.15);
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }
        
        #userMessageInput {
            flex: 1;
            padding: 14px 18px;
            border-radius: 12px;
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.95);
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            font-weight: 400;
        }
        
        #userMessageInput::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }
        
        #userMessageInput:focus {
            outline: none;
        }
        
        #userMessageInput:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #sendMessageBtn {
            padding: 14px 24px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            box-shadow: 0 4px 14px rgba(102, 126, 234, 0.4);
        }
        
        #sendMessageBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        #sendMessageBtn:active:not(:disabled) {
            transform: translateY(0);
        }
        
        #sendMessageBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        /* Smooth animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .chat-container {
            animation: fadeIn 0.5s ease-out;
        }
        
        /* Improved button icons */
        button svg {
            transition: transform 0.3s ease;
        }
        
        button:hover:not(:disabled) svg {
            transform: scale(1.1);
        }
        
        /* Better focus states */
        *:focus-visible {
            outline: 2px solid rgba(102, 126, 234, 0.6);
            outline-offset: 2px;
            border-radius: 4px;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 16px;
            }
            
            h1 {
                font-size: 2rem;
                margin-bottom: 16px;
            }
            
            .status-indicator {
                padding: 14px 20px;
                font-size: 0.9rem;
            }
            
            .chat-container {
                padding: 20px;
                grid-template-columns: 1fr;
                gap: 24px;
                border-radius: 20px;
            }
            
            .button-group {
                flex-direction: column;
                gap: 10px;
            }
            
            button {
                width: 100%;
                padding: 14px 24px;
            }
            
            .message-input-wrapper {
                flex-direction: column;
                gap: 10px;
                padding: 8px;
            }
            
            #sendMessageBtn {
                width: 100%;
                justify-content: center;
            }
            
            #chatHistory {
                max-height: 300px;
                min-height: 300px;
                padding: 20px;
            }
            
            #remoteVideo {
                border-radius: 16px;
            }
            
            .video-container {
                flex-direction: column;
            }
            
            .engagement-bar-container {
                flex-direction: row;
                width: 100%;
                min-width: auto;
                padding: 8px 16px;
            }
            
            .engagement-bar-wrapper {
                width: 100%;
                height: 24px;
                max-width: 400px;
            }
            
            .engagement-bar-label {
                writing-mode: horizontal-tb;
                text-orientation: mixed;
                margin-bottom: 0;
                margin-right: 8px;
            }
            
            .engagement-bar-value {
                transform: translate(-50%, -50%);
                transform-origin: center;
            }
            
            .engagement-level-indicator {
                margin-top: 0;
                margin-left: 8px;
            }

            .signifier-label { flex: 0 0 100px; }
            .signifier-panel-groups { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>Business Meeting Copilot</h1>

        <div class="status-indicator">
            <p>AI-powered meeting coach with speech recognition and talking avatar. Click "Initialize Avatar Session" to start, then "Start Microphone" for voice interaction.</p>
        </div>

        <div class="button-group">
            <button id="initAvatar" onclick="initializeAvatarSession()">Initialize Avatar Session</button>
            <button id="selectVideoSource" onclick="promptVideoSourceSelection(true)" class="secondary" style="display: none;">Change Video Source</button>
            <button id="microphone" onclick="microphone()" disabled>Start Microphone</button>
            <button id="stopSpeaking" onclick="stopSpeaking()" disabled>Stop Speaking</button>
            <button id="clearChatHistory" onclick="clearChatHistory()" class="secondary">Clear Chat History</button>
            <button id="stopSession" onclick="stopSession()" disabled class="danger">Close Avatar Session</button>
        </div>

        <div class="chat-container">
            <div class="video-section">
                <div class="video-container">
                    <div class="engagement-bar-container">
                        <div class="engagement-bar-label">Engagement</div>
                        <div class="engagement-bar-wrapper">
                            <div class="engagement-bar-fill" id="engagementBarFill"></div>
                            <div class="engagement-bar-value" id="engagementBarValue">--</div>
                        </div>
                        <div class="engagement-level-indicator" id="engagementLevel">--</div>
                    </div>
                    <div id="remoteVideo" style="position: relative; flex: 1;">
                        <div id="subtitles" hidden></div>
                    </div>
                </div>
                
                <div class="message-input-container">
                    <div class="message-input-wrapper">
                        <input 
                            type="text" 
                            id="userMessageInput" 
                            placeholder="Type your message here or use microphone..." 
                            disabled
                            onkeypress="handleMessageKeyPress(event)"
                        />
                        <button id="sendMessageBtn" onclick="sendMessage()" disabled>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="22" y1="2" x2="11" y2="13"></line>
                                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                            </svg>
                            Send
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="chat-transcription-section">
                <div class="chat-transcription-header">Chat Conversation</div>
                <div id="chatHistory" contentEditable="true"></div>
            </div>
        </div>

        <div id="signifierPanelContainer" class="engagement-signifiers-panel"></div>
    </div>

    <!-- Modular JavaScript Modules -->
    <script src="/static/js/engagement-bar.js"></script>
    <script src="/static/js/signifier-panel.js"></script>
    <script src="/static/js/engagement-detector.js"></script>
    <script src="/static/js/session-manager.js"></script>
    <script src="/static/js/avatar-chat-manager.js"></script>
    <script src="/static/js/video-source-selector.js"></script>

    <script>
        // ========================================================================
        // Global Variables & Configuration
        // ========================================================================
        var speechRecognizer
        var avatarSynthesizer
        var peerConnection
        var peerConnectionDataChannel
        var appConfig = null
        
        // Session Management (modular)
        var sessionManager = null
        var avatarChatManager = null
        var engagementBarDisplay = null
        var engagementDetector = null
        var signifierPanel = null
        var videoSourceSelector = null
        
        // UI State
        var avatarAudioInitialized = false
        var sessionActive = false
        var dataSources = []
        var videoSourcePromptShown = false  // Track if video source prompt has been shown

        // ========================================================================
        // Engagement Alerts (drop / plateau)
        // ========================================================================
        
        /**
         * Handle engagement alert from backend (significant drop or plateau).
         * Avatar interrupts current response and speaks the alert and suggestions.
         */
        function handleEngagementAlert(alert) {
            if (!alert || !alert.message) return;
            if (!avatarChatManager || !avatarAudioInitialized) {
                console.warn('Engagement alert received but avatar not ready:', alert.type);
                return;
            }
            avatarChatManager.interruptCurrentResponse();
            var parts = [alert.message];
            if (alert.suggestions && alert.suggestions.length) {
                parts.push(alert.suggestions.slice(0, 3).join(' '));
            }
            var text = parts.join(' ');
            setTimeout(function () { avatarChatManager.speak(text); }, 120);
        }
        
        // ========================================================================
        // System Initialization
        // ========================================================================
        
        /**
         * Initialize all systems (engagement detection, session manager).
         * Avatar chat manager is initialized when avatar session starts.
         */
        function initializeSystems() {
            try {
                // Initialize engagement bar display
                engagementBarDisplay = new EngagementBarDisplay({
                    updateInterval: 500
                });

                // Initialize 30-metrics signifier panel (beneath avatar chat)
                signifierPanel = new SignifierPanel({ containerId: 'signifierPanelContainer' });
                signifierPanel.init();
                
                // Initialize engagement detector
                engagementDetector = new EngagementDetector({
                    barDisplay: engagementBarDisplay,
                    signifierPanel: signifierPanel,
                    apiBaseUrl: 'http://localhost:5000',
                    pollInterval: 500,
                    onAlert: handleEngagementAlert
                });
                
                // Initialize session manager
                sessionManager = new SessionManager({
                    engagementDetector: engagementDetector,
                    apiBaseUrl: 'http://localhost:5000'
                });
                
                // Initialize video source selector
                videoSourceSelector = new VideoSourceSelector({
                    onSelect: handleVideoSourceSelected,
                    onCancel: handleVideoSourceCanceled
                });
                
                // Show "Change Video Source" button after initialization
                const changeSourceBtn = document.getElementById('selectVideoSource');
                if (changeSourceBtn) {
                    changeSourceBtn.style.display = 'inline-block';
                }
                
                console.log('Core systems initialized (engagement + session manager + video source selector)');
            } catch (error) {
                console.error('Error initializing systems:', error);
            }
        }
        
        // ========================================================================
        // Video Source Selection
        // ========================================================================
        
        /**
         * Prompt user to select video source for engagement detection.
         * 
         * @param {boolean} force - Force show even if already shown (default: false)
         */
        function promptVideoSourceSelection(force = false) {
            // Don't show if already shown (unless forced)
            if (videoSourcePromptShown && !force) {
                return;
            }
            
            if (!videoSourceSelector) {
                console.warn('Video source selector not initialized');
                // Fallback to default (stream) with MediaPipe if systems are ready
                if (sessionManager) {
                    sessionManager.startSession('stream', null, 'mediapipe').catch(err => {
                        console.warn('Could not start parallel session:', err);
                    });
                }
                return;
            }
            
            videoSourceSelector.show();
            videoSourcePromptShown = true;
        }
        
        /**
         * Handle video source selection.
         * 
         * @param {Object} selection - Selected video source options
         */
        async function handleVideoSourceSelected(selection) {
            const { sourceType, sourcePath, file, detectionMethod } = selection;
            
            try {
                // If file is selected, upload it first
                let finalSourcePath = sourcePath;
                
                if (sourceType === 'file' && file) {
                    // Show loading indicator
                    const confirmBtn = document.querySelector('#confirmVideoSource');
                    const originalText = confirmBtn.textContent;
                    confirmBtn.textContent = 'Uploading...';
                    confirmBtn.disabled = true;
                    
                    try {
                        // Upload file to server
                        const formData = new FormData();
                        formData.append('video', file);
                        
                        const uploadResponse = await fetch('http://localhost:5000/engagement/upload-video', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (!uploadResponse.ok) {
                            const errorData = await uploadResponse.json().catch(() => ({ error: 'Upload failed' }));
                            throw new Error(errorData.error || 'Failed to upload video file');
                        }
                        
                        const uploadResult = await uploadResponse.json();
                        finalSourcePath = uploadResult.filePath;
                    } finally {
                        confirmBtn.textContent = originalText;
                        confirmBtn.disabled = false;
                    }
                }
                
                // Start session with selected source and detection method
                // Note: This starts engagement detection, but avatar session is separate
                // Default to 'mediapipe' if not specified
                const selectedDetectionMethod = detectionMethod || 'mediapipe';
                
                if (sessionManager) {
                    await sessionManager.startSession(sourceType, finalSourcePath, selectedDetectionMethod);
                    console.log(`Engagement detection started with source: ${sourceType}, method: ${selectedDetectionMethod}`);
                    
                    // Show success message
                    console.log('âœ“ Video source selected and engagement detection started');
                }
            } catch (error) {
                console.error('Error starting engagement detection with selected source:', error);
                alert(`Failed to start engagement detection: ${error.message}\n\nPlease try again or select a different source.`);
            }
        }
        
        /**
         * Handle video source selection cancellation.
         */
        function handleVideoSourceCanceled() {
            console.log('Video source selection canceled');
            // Mark as shown so it doesn't pop up again automatically
            videoSourcePromptShown = true;
            
            // Optionally start with default (webcam) if user cancels
            // Or leave it so user can manually start later
            // For now, we'll just mark it as shown and let user start manually
        }

        // Configuration from backend
        async function loadConfig() {
            try {
                const response = await fetch('http://localhost:5000/config/all')
                if (!response.ok) {
                    throw new Error(`Failed to fetch config: ${response.status}`)
                }
                appConfig = await response.json()
                console.log('Configuration loaded from backend', appConfig)
            } catch (error) {
                console.error('Failed to load configuration:', error)
                alert('Failed to load configuration from backend. Please ensure the server is running.')
            }
        }

        // Initialize avatar session with video and audio
        async function initializeAvatarSession() {
            if (!appConfig) {
                await loadConfig()
            }
            
            if (!appConfig) {
                alert('Failed to load configuration. Please refresh the page.')
                return
            }

            const cogSvcRegion = appConfig.speech.region
            const privateEndpointEnabled = appConfig.speech.privateEndpointEnabled || false

            // Get speech token from backend
            const tokenRes = await fetch('http://localhost:5000/speech/token')
            if (!tokenRes.ok) {
                alert('Failed to get speech token from backend.')
                return
            }
            const { token } = await tokenRes.json()

            // Initialize Avatar Synthesizer for TTS
            let speechSynthesisConfig
            const isCustomAvatar = appConfig.avatar.customized
            const isCustomVoice = appConfig.sttTts.customVoiceEndpointId && appConfig.sttTts.customVoiceEndpointId !== ''
            
            if (privateEndpointEnabled) {
                const privateEndpoint = appConfig.speech.privateEndpoint || ''
                let endpoint_route = isCustomAvatar || isCustomVoice ? 'voice' : 'tts'
                speechSynthesisConfig = SpeechSDK.SpeechConfig.fromEndpoint(
                    new URL(`wss://${privateEndpoint}/${endpoint_route}/cognitiveservices/websocket/v1?enableTalkingAvatar=true`),
                    token
                )
            } else {
                speechSynthesisConfig = SpeechSDK.SpeechConfig.fromAuthorizationToken(token, cogSvcRegion)
            }
            speechSynthesisConfig.endpointId = appConfig.sttTts.customVoiceEndpointId || ''

            const talkingAvatarCharacter = appConfig.avatar.character
            const talkingAvatarStyle = appConfig.avatar.style
            const avatarConfig = new SpeechSDK.AvatarConfig(talkingAvatarCharacter, talkingAvatarStyle)
            avatarConfig.photoAvatarBaseModel = appConfig.avatar.photoAvatar ? 'vasa-1' : ''
            avatarConfig.customized = appConfig.avatar.customized
            avatarConfig.useBuiltInVoice = appConfig.avatar.useBuiltInVoice
            avatarSynthesizer = new SpeechSDK.AvatarSynthesizer(speechSynthesisConfig, avatarConfig)
            
            avatarSynthesizer.avatarEventReceived = function (s, e) {
                var offsetMessage = ", offset from session start: " + e.offset / 10000 + "ms."
                if (e.offset === 0) {
                    offsetMessage = ""
                }
                console.log("Avatar event received: " + e.description + offsetMessage)
            }

            // Initialize Speech Recognizer for STT
            let speechRecognitionConfig
            if (privateEndpointEnabled) {
                const privateEndpoint = appConfig.speech.privateEndpoint || ''
                speechRecognitionConfig = SpeechSDK.SpeechConfig.fromEndpoint(
                    new URL(`wss://${privateEndpoint}/stt/speech/universal/v2`),
                    token
                )
            } else {
                speechRecognitionConfig = SpeechSDK.SpeechConfig.fromAuthorizationToken(token, cogSvcRegion)
            }
            speechRecognitionConfig.setProperty(SpeechSDK.PropertyId.SpeechServiceConnection_LanguageIdMode, "Continuous")
            var sttLocales = appConfig.sttTts.sttLocales.split(',')
            var autoDetectSourceLanguageConfig = SpeechSDK.AutoDetectSourceLanguageConfig.fromLanguages(sttLocales)
            speechRecognizer = SpeechSDK.SpeechRecognizer.FromConfig(
                speechRecognitionConfig,
                autoDetectSourceLanguageConfig,
                SpeechSDK.AudioConfig.fromDefaultMicrophoneInput()
            )

            // Initialize messages
            // Messages are initialized by avatarChatManager when ready
            // Fallback initialization if chat manager not ready yet
            if (!avatarChatManager && appConfig) {
                initMessages();
            }

            // Get relay token and set up WebRTC for avatar audio
            const relayRes = await fetch('http://localhost:5000/avatar/relay-token')
            if (!relayRes.ok) {
                alert('Failed to get relay token from backend.')
                return
            }
            const relayData = await relayRes.json()
            const iceServerUrl = relayData.Urls[0]
            const iceServerUsername = relayData.Username
            const iceServerCredential = relayData.Password
            setupWebRTCForAudio(iceServerUrl, iceServerUsername, iceServerCredential)
        }

        // Setup WebRTC connection for avatar video and audio
        function setupWebRTCForAudio(iceServerUrl, iceServerUsername, iceServerCredential) {
            peerConnection = new RTCPeerConnection({
                iceServers: [{
                    urls: [iceServerUrl],
                    username: iceServerUsername,
                    credential: iceServerCredential
                }]
            })

            // Handle audio and video tracks from avatar
            peerConnection.ontrack = function (event) {
                if (event.track.kind === 'audio') {
                    let audioElement = document.createElement('audio')
                    audioElement.id = 'audioPlayer'
                    audioElement.srcObject = event.streams[0]
                    audioElement.autoplay = false
                    audioElement.addEventListener('loadeddata', () => {
                        audioElement.play()
                    })
                    audioElement.onplaying = () => {
                        console.log(`WebRTC ${event.track.kind} channel connected.`)
                    }

                    let remoteVideoDiv = document.getElementById('remoteVideo')
                    // Remove existing audio element if present
                    for (var i = 0; i < remoteVideoDiv.childNodes.length; i++) {
                        if (remoteVideoDiv.childNodes[i].localName === 'audio') {
                            remoteVideoDiv.removeChild(remoteVideoDiv.childNodes[i])
                        }
                    }
                    document.getElementById('remoteVideo').appendChild(audioElement)
                }

                if (event.track.kind === 'video') {
                    let videoElement = document.createElement('video')
                    videoElement.id = 'videoPlayer'
                    videoElement.srcObject = event.streams[0]
                    videoElement.autoplay = false
                    videoElement.addEventListener('loadeddata', () => {
                        videoElement.play()
                    })
                    videoElement.playsInline = true
                    videoElement.style.width = '0.5px'
                    document.getElementById('remoteVideo').appendChild(videoElement)

                    videoElement.onplaying = () => {
                        let remoteVideoDiv = document.getElementById('remoteVideo')
                        // Remove existing video element if present
                        for (var i = 0; i < remoteVideoDiv.childNodes.length; i++) {
                            if (remoteVideoDiv.childNodes[i].localName === 'video') {
                                remoteVideoDiv.removeChild(remoteVideoDiv.childNodes[i])
                            }
                        }
                        videoElement.style.width = '100%'
                        document.getElementById('remoteVideo').appendChild(videoElement)

                        console.log(`WebRTC ${event.track.kind} channel connected.`)
                        avatarAudioInitialized = true
                        sessionActive = true
                        document.getElementById('initAvatar').disabled = true
                        document.getElementById('microphone').disabled = false
                        document.getElementById('stopSession').disabled = false
                        document.getElementById('userMessageInput').disabled = false
                        document.getElementById('sendMessageBtn').disabled = false
                        document.getElementById('userMessageInput').focus()
                        
                        // Video source should already be selected from initial prompt
                        // Only prompt again if it wasn't shown initially
                        if (!videoSourcePromptShown && videoSourceSelector) {
                            promptVideoSourceSelection();
                        }
                    }
                }
            }

            // Handle data channel for avatar events (subtitles, etc.)
            peerConnection.addEventListener("datachannel", event => {
                peerConnectionDataChannel = event.channel
            peerConnectionDataChannel.onmessage = e => {
                let subtitles = document.getElementById('subtitles')
                const webRTCEvent = JSON.parse(e.data)
                if (webRTCEvent.event.eventType === 'EVENT_TYPE_TURN_START' && appConfig.avatar.showSubtitles) {
                    subtitles.hidden = false
                    // Get current speaking text from avatar chat manager if available
                    if (avatarChatManager && avatarChatManager.speakingText) {
                        subtitles.innerHTML = avatarChatManager.speakingText
                    }
                } else if (webRTCEvent.event.eventType === 'EVENT_TYPE_SESSION_END' || webRTCEvent.event.eventType === 'EVENT_TYPE_SWITCH_TO_IDLE') {
                    subtitles.hidden = true
                }
                console.log("[" + (new Date()).toISOString() + "] WebRTC event received: " + e.data)
            }
            })

            // Create data channel for events
            let c = peerConnection.createDataChannel("eventChannel")

            peerConnection.oniceconnectionstatechange = e => {
                console.log("WebRTC status: " + peerConnection.iceConnectionState)
            }

            // Add transceivers for both audio and video
            peerConnection.addTransceiver('video', { direction: 'sendrecv' })
            peerConnection.addTransceiver('audio', { direction: 'sendrecv' })

            // Start avatar synthesizer
            avatarSynthesizer.startAvatarAsync(peerConnection).then((r) => {
                if (r.reason === SpeechSDK.ResultReason.SynthesizingAudioCompleted) {
                    console.log("[" + (new Date()).toISOString() + "] Avatar started. Result ID: " + r.resultId)
                    
                    // Initialize avatar chat manager now that avatar is ready
                    if (sessionManager && !avatarChatManager) {
                        avatarChatManager = new AvatarChatManager({
                            sessionManager: sessionManager,
                            avatarSynthesizer: avatarSynthesizer,
                            appConfig: appConfig
                        });
                        console.log('Avatar chat manager initialized');
                    }
                    
                    avatarAudioInitialized = true;
                    sessionActive = true;
                } else {
                    console.log("[" + (new Date()).toISOString() + "] Unable to start avatar. Result ID: " + r.resultId)
                    if (r.reason === SpeechSDK.ResultReason.Canceled) {
                        let cancellationDetails = SpeechSDK.CancellationDetails.fromResult(r)
                        if (cancellationDetails.reason === SpeechSDK.CancellationReason.Error) {
                            console.log(cancellationDetails.errorDetails)
                        }
                        console.log("Unable to start avatar: " + cancellationDetails.errorDetails)
                    }
                    document.getElementById('initAvatar').disabled = false
                }
            }).catch((error) => {
                console.log("[" + (new Date()).toISOString() + "] Avatar failed to start. Error: " + error)
                alert("Failed to initialize avatar session: " + error)
                document.getElementById('initAvatar').disabled = false
            })
        }
        
        // ========================================================================
        // Session Management
        // ========================================================================
        
        /**
         * Stop avatar session and clean up all resources.
         */
        async function stopSession() {
            // Stop parallel session (engagement detection + chat)
            if (sessionManager) {
                await sessionManager.stopSession();
            }
            
            // Stop avatar synthesizer
            if (avatarSynthesizer !== undefined) {
                avatarSynthesizer.close();
            }
            
            // Stop speech recognizer
            if (speechRecognizer !== undefined) {
                speechRecognizer.stopContinuousRecognitionAsync();
                speechRecognizer.close();
            }
            
            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
            }
            
            // Update state
            sessionActive = false;
            avatarAudioInitialized = false;
            
            // Clear video element
            let remoteVideoDiv = document.getElementById('remoteVideo');
            while (remoteVideoDiv.firstChild) {
                if (remoteVideoDiv.firstChild.id !== 'subtitles') {
                    remoteVideoDiv.removeChild(remoteVideoDiv.firstChild);
                }
            }
            
            // Update UI
            document.getElementById('initAvatar').disabled = false;
            document.getElementById('microphone').disabled = true;
            document.getElementById('stopSession').disabled = true;
            document.getElementById('userMessageInput').disabled = true;
            document.getElementById('userMessageInput').value = '';
            document.getElementById('sendMessageBtn').disabled = true;
            document.getElementById('stopSpeaking').disabled = true;
        }

        // HTML encoding
        function htmlEncode(text) {
            const entityMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;',
                '/': '&#x2F;'
            }
            return String(text).replace(/[&<>"'\/]/g, (match) => entityMap[match])
        }

        // ========================================================================
        // Message Management
        // ========================================================================
        
        /**
         * Initialize messages array.
         */
        function initMessages() {
            if (avatarChatManager) {
                avatarChatManager.initMessages();
            }
            
            // Initialize data sources for cognitive search
            if (!appConfig) {
                console.error('Configuration not loaded');
                return;
            }
            
            if (appConfig.cognitiveSearch && appConfig.cognitiveSearch.enabled) {
                dataSources = [{
                    type: 'AzureCognitiveSearch',
                    parameters: {
                        endpoint: appConfig.cognitiveSearch.endpoint,
                        key: appConfig.cognitiveSearch.apiKey,
                        indexName: appConfig.cognitiveSearch.indexName,
                        semanticConfiguration: '',
                        queryType: 'simple',
                        fieldsMapping: {
                            contentFieldsSeparator: '\n',
                            contentFields: ['content'],
                            filepathField: null,
                            titleField: 'title',
                            urlField: null
                        },
                        inScope: true,
                        roleInformation: appConfig.systemPrompt
                    }
                }];
            } else {
                dataSources = [];
            }
        }
        
        /**
         * Clear chat history.
         */
        function clearChatHistory() {
            if (avatarChatManager) {
                avatarChatManager.clearChatHistory();
            }
            initMessages();
        }

        // ========================================================================
        // Speech Functions (Delegated to AvatarChatManager)
        // ========================================================================
        
        // ========================================================================
        // Speech Functions (Delegated to AvatarChatManager)
        // ========================================================================
        
        // ========================================================================
        // Speech Functions (Delegated to AvatarChatManager)
        // ========================================================================
        
        /**
         * Speak text - delegates to AvatarChatManager.
         * Kept for backward compatibility with existing code.
         */
        function speak(text, endingSilenceMs = 0) {
            if (avatarChatManager) {
                avatarChatManager.speak(text, endingSilenceMs);
            }
        }
        
        /**
         * Stop speaking - delegates to AvatarChatManager.
         * Kept for backward compatibility with existing code.
         */
        function stopSpeaking() {
            if (avatarChatManager) {
                avatarChatManager.stopSpeaking();
            }
        }
        
        // Expose isSpeaking for UI updates (delegates to AvatarChatManager)
        // This allows existing code that checks isSpeaking to continue working
        Object.defineProperty(window, 'isSpeaking', {
            get: function() {
                return avatarChatManager ? avatarChatManager.isSpeaking : false;
            },
            configurable: true
        });

        // ========================================================================
        // Chat Handling (Streamlined)
        // ========================================================================
        
        /**
         * Handle user query - streamlined version using AvatarChatManager.
         * 
         * @param {string} userQuery - User's message
         * @param {string} userQueryHTML - HTML formatted user query
         * @param {string} imgUrlPath - Optional image URL path
         */
        async function handleUserQuery(userQuery, userQueryHTML, imgUrlPath) {
            if (!avatarChatManager) {
                console.error('Avatar chat manager not initialized');
                return;
            }
            
            await avatarChatManager.handleUserQuery(userQuery, userQueryHTML, imgUrlPath);
        }


        function microphone() {
            if (!speechRecognizer || !avatarAudioInitialized || !sessionActive) {
                alert('Please initialize avatar session first, then start microphone.')
                return
            }

            if (document.getElementById('microphone').innerHTML === 'Stop Microphone') {
                document.getElementById('microphone').disabled = true
                speechRecognizer.stopContinuousRecognitionAsync(() => {
                    document.getElementById('microphone').innerHTML = 'Start Microphone'
                    document.getElementById('microphone').disabled = false
                }, (err) => {
                    console.log("Failed to stop continuous recognition:", err)
                    document.getElementById('microphone').disabled = false
                })
                return
            }

            document.getElementById('microphone').disabled = true

            // Pause avatar as soon as user starts speaking (interim results)
            speechRecognizer.recognizing = (s, e) => {
                if (e.result.reason !== SpeechSDK.ResultReason.RecognizingSpeech) return;
                const partial = (e.result.text || '').trim();
                if (partial.length < 2) return;
                if (avatarChatManager && (avatarChatManager.isSpeaking || (avatarChatManager.sessionManager && avatarChatManager.sessionManager.isStreaming))) {
                    avatarChatManager.interruptCurrentResponse();
                }
            };

            speechRecognizer.recognized = async (s, e) => {
                if (e.result.reason === SpeechSDK.ResultReason.RecognizedSpeech) {
                    let userQuery = e.result.text.trim()
                    if (userQuery === '') {
                        return
                    }

                    // Interrupt avatar chat if still speaking/streaming (in case recognizing didn't fire)
                    if (avatarChatManager) {
                        avatarChatManager.interruptCurrentResponse();
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }

                    if (!appConfig || !appConfig.sttTts || !appConfig.sttTts.continuousConversation) {
                        document.getElementById('microphone').disabled = true
                        speechRecognizer.stopContinuousRecognitionAsync(() => {
                            document.getElementById('microphone').innerHTML = 'Start Microphone'
                            document.getElementById('microphone').disabled = false
                        }, (err) => {
                            console.log("Failed to stop continuous recognition:", err)
                            document.getElementById('microphone').disabled = false
                        })
                    }

                    handleUserQuery(userQuery, "", "")
                }
            }

            speechRecognizer.startContinuousRecognitionAsync(() => {
                document.getElementById('microphone').innerHTML = 'Stop Microphone'
                document.getElementById('microphone').disabled = false
            }, (err) => {
                console.log("Failed to start continuous recognition:", err)
                document.getElementById('microphone').disabled = false
            })
        }

        // Message sending functions
        function handleMessageKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault()
                sendMessage()
            }
        }
        
        async function sendMessage() {
            const input = document.getElementById('userMessageInput')
            const sendBtn = document.getElementById('sendMessageBtn')
            const message = input.value.trim()
            
            if (!message) {
                return
            }
            
            if (!appConfig) {
                alert('Configuration not loaded. Please refresh the page.')
                return
            }
            
            if (!avatarAudioInitialized || !sessionActive) {
                alert('Please initialize avatar session first.')
                return
            }
            
            // Interrupt avatar chat if speaking
            if (avatarChatManager) {
                avatarChatManager.interruptCurrentResponse();
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // Disable input and button while processing
            input.disabled = true
            sendBtn.disabled = true
            
            // Clear input immediately for better UX
            input.value = ''
            
            // Send the message
            handleUserQuery(message, message, "")
            
            // Re-enable input and button after a brief moment
            setTimeout(() => {
                input.disabled = false
                sendBtn.disabled = false
                input.focus()
            }, 300)
        }

        // ========================================================================
        // Initialization
        // ========================================================================
        
        // Initialize systems when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initializeSystems();
                // Show video source prompt after systems are initialized
                setTimeout(() => {
                    promptVideoSourceSelection();
                }, 500); // Small delay to ensure DOM is fully ready
            });
        } else {
            initializeSystems();
            // Show video source prompt after systems are initialized
            setTimeout(() => {
                promptVideoSourceSelection();
            }, 500);
        }

        window.onload = () => {
            loadConfig().then(() => {
                // Initialize messages after config is loaded
                if (avatarChatManager) {
                    avatarChatManager.initMessages();
                } else {
                    initMessages();
                }
            });
            
            // Ensure systems are initialized
            if (!sessionManager || !engagementBarDisplay || !engagementDetector) {
                initializeSystems();
            }
            
            // Show video source prompt if not already shown
            if (!videoSourcePromptShown) {
                setTimeout(() => {
                    promptVideoSourceSelection();
                }, 1000); // Delay to ensure everything is ready
            }
        }
    </script>
</body>
</html>
